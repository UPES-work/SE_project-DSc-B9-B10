# ğŸš€ Quick Commerce Dark Store Management System (QCDSMS)

## ğŸ“˜ Table of Contents
- [Overview](#overview)
- [Problem Statement](#problem-statement)
- [Key Features](#key-features)
- [Target Users](#target-users)
- [Tools & Technologies Used](#tools--technologies-used)
- [Package Dependencies](#package-dependencies)
- [System Requirements](#system-requirements)
- [Steps to Run the Project](#steps-to-run-the-project)
- [System Architecture](#system-architecture)
- [Workflows](#workflows)
- [SDLC Model Adopted](#sdlc-model-adopted)
- [Requirement Gathering Approach](#requirement-gathering-approach)
- [Testing Method](#testing-method)
- [Deployment Instructions](#deployment-instructions)
- [Challenges Faced](#challenges-faced)
- [Future Enhancements](#future-enhancements)
- [Team Members](#team-members)
- [Feedback & Contributions](#feedback--contributions)


## ğŸ§¹ Overview
The Quick Commerce Dark Store Management System (QCDSMS) is a cloud-based web application built using Flask to streamline the operations of dark stores â€” specialized facilities dedicated to rapid 
fulfillment of online orders. QCDSMS improves inventory control, order processing, logistics coordination, and enables AI-powered data analytics.

## â“ Problem Statement
Dark stores face several operational inefficiencies, including:
- Poor inventory visibility
- Delayed dispatches
- Inefficient last-mile delivery coordination
- Lack of real-time analytics

QCDSMS addresses these problems with:
- Real-time inventory tracking
- Automated order assignment and dispatching
- Integration with third-party delivery APIs
- AI-based demand forecasting and performance reporting

## âœ¨ Key Features
- ğŸ“¦ **Inventory Management:** Automatic stock updates, restocking alerts, and audit tools.
- ğŸšš **Order Management:** Real-time validation, processing, and dispatch.
- ğŸ“¡ **Delivery Coordination:** Seamless integration with logistics APIs for real-time tracking.
- ğŸ“Š **AI Analytics:** Sales forecasting and performance dashboards.
- ğŸ” **Security:** Role-Based Access Control (RBAC), Multi-Factor Authentication (MFA), and audit logging.
- ğŸ–¥ï¸ **User Dashboard:** Clean, responsive interface for managing store operations.

## ğŸ‘¥ Target Users
- **Store Managers:** Oversee stock and fulfill orders.
- **Delivery Partners:** Receive assignments and update delivery status.
- **Customers:** Track their orders through integrated platforms.
- **Business Analysts/Admins:** Use reporting tools for insights and decision-making.


## ğŸ› ï¸ Tools & Technologies Used
|----------------------|--------------------------------------|
| Category             | Tools / Technologies                 |
|----------------------|--------------------------------------|
| Backend Framework    | Python (Flask)                       |
| Frontend             | HTML, CSS (Jinja2 Templates)         |
| Database             | SQLite                               |
| Version Control      | Git, GitHub                          |
| Testing Framework    | Pytest                               |
| Deployment Platform  | AWS / Heroku (Planned)               |
| Integrations         | E-commerce & Logistics APIs          |
|----------------------|--------------------------------------|

## ğŸ“¦ Package Dependencies
To install required dependencies, run:
bash
pip install flask pytest
> Note: `sqlite3` comes built-in with Python 3.x and does not require installation.

## ğŸ–¥ï¸ System Requirements
- Python 3.6 or higher
- Internet connectivity for cloud-based features
- Modern web browser (Chrome, Firefox, etc.)
- Local or cloud-based system for deployment/testing

## ğŸ”§ Steps to Run the Project
### Step 1: Navigate to the Project Directory
cd "C:\Users\ASUS\OneDrive\Ayush Kumar\OneDrive\Desktop\codeing\software engineer"

### Step 2: List Files in the Project Directory
dir

### Step 3: Check Files Inside the Templates Folder
dir templates

### Step 4: Activate the Virtual Environment
C:\Users\ASUS\venv\Scripts\activate

### Step 5: Verify Flask Installation
pip show flask

### Step 6: Run the Flask Application
python softwarep1.py

Once you run the last command, your Flask application will be live at http://127.0.0.1:5000!

## ğŸ§± System Architecture
### Major Components:
-SQLite Database:Stores inventory, users, orders, and delivery data.
-Flask Application Server:Manages business logic, routing, and communication.
-Web Interface:Dashboard built with HTML/CSS for managers and admins.
-External APIs:For logistics, payment, and e-commerce platforms.

### Conceptual Flow:
Browser (User)
     â†“
Web Server (Flask + Jinja2)
     â†“
Business Logic Layer
     â†“
SQLite Database
     â†“          â†˜
Logistics APIs   AI Forecast Engine

## ğŸ”„ Workflows
### 1. Order Processing
- Customer places an order.
- Inventory is checked and validated.
- System assigns the order to an available delivery partner.
- The order is dispatched and tracked.
- Confirmation is sent upon successful delivery.

### 2. Inventory Management
- Stocks are updated in real-time.
- Alerts are generated for low stock.
- Admins conduct audits or make adjustments.
- Integration with IoT for live updates.

### 3. Delivery Assignment
- Orders are assigned based on availability and location.
- Real-time GPS tracking.
- Delays or failures are logged and managed with notifications.

---

## ğŸ”€ SDLC Model Adopted
Agile Development Methodology
- Continuous iteration and prototyping
- Bi-weekly sprints and testing cycles
- Frequent stakeholder feedback
- Adaptability to changing requirements

## ğŸ“‹ Requirement Gathering Approach
- Conducted interviews with domain experts
- Benchmarked against market leaders
- Created workflow diagrams and use-case models
- Validated through prototype feedback and iterations

## ğŸ§ª Testing Method
- **Unit Testing:** Validated backend logic using `pytest`
- **Manual Testing:** Verified UI workflows manually across use cases
- **Performance Testing:** Ensured <2s response time for critical functions

## â˜ï¸ Deployment Instructions
Target Platforms:AWS EC2, Heroku

> For Heroku Deployment:
1. Create a `Procfile`:web: python app.py
2. Commit and push to Heroku Git repo
3. Configure environment variables
4. Deploy and monitor logs using Heroku CLI


## ğŸ§¬ Challenges Faced
|------------------------------------------|----------------------------------------------|
| Challenge                                | Resolution                                   |
|------------------------------------------|----------------------------------------------|
| Unstable third-party API responses       | Implemented retries and timeouts             |
| Module synchronization issues            | Used task queues and batched processing      |
| Performance optimization                 | Indexed queries and enabled caching          |
| Secure access control                    | Enforced MFA and implemented RBAC            |
|------------------------------------------|----------------------------------------------|

## ğŸŒ± Future Enhancements
- ğŸ”® Enhanced machine learning for AI forecasting
- ğŸŒ Blockchain integration for secure order history
- ğŸ“¡ IoT-based inventory tracking in real time
- ğŸ“± Native mobile app for delivery agents
- ğŸ“Š Dynamic reporting with export options
- ğŸŒ¿ Eco-routing for reduced emissions

## ğŸ‘¨â€ğŸ’¼ Team Members

|----------------|--------------|-----------------------------------------|
| Name           | SAP ID       | Role                                    |
|----------------|--------------|-----------------------------------------|
| Dhariya Harit  | 500122012    | Backend Developer                       |
| Ayush Kumar    | 500124275    | System Architect & Full Stack Developer |
|----------------|--------------|-----------------------------------------|

## ğŸ“© Feedback & Contributions
We welcome community feedback, bug reports, and feature suggestions. Feel free to fork the repo, submit issues, or open pull requests to collaborate on improvements.
